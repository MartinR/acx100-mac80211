/* src/acx100.c - main module functions
 *
 * --------------------------------------------------------------------
 *
 * Copyright (C) 2003  ACX100 Open Source Project
 *
 *   The contents of this file are subject to the Mozilla Public
 *   License Version 1.1 (the "License"); you may not use this file
 *   except in compliance with the License. You may obtain a copy of
 *   the License at http://www.mozilla.org/MPL/
 *
 *   Software distributed under the License is distributed on an "AS
 *   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 *   implied. See the License for the specific language governing
 *   rights and limitations under the License.
 *
 *   Alternatively, the contents of this file may be used under the
 *   terms of the GNU Public License version 2 (the "GPL"), in which
 *   case the provisions of the GPL are applicable instead of the
 *   above.  If you wish to allow the use of your version of this file
 *   only under the terms of the GPL and not to allow others to use
 *   your version of this file under the MPL, indicate your decision
 *   by deleting the provisions above and replace them with the notice
 *   and other provisions required by the GPL.  If you do not delete
 *   the provisions above, a recipient may use your version of this
 *   file under either the MPL or the GPL.
 *
 * --------------------------------------------------------------------
 *
 * Inquiries regarding the ACX100 Open Source Project can be
 * made directly to:
 *
 * acx100-users@lists.sf.net
 * http://acx100.sf.net
 *
 * --------------------------------------------------------------------
 * Locking and synchronization (taken from orinoco.c):
 *
 * The basic principle is that everything is serialized through a
 * single spinlock, wlandev->lock.  The lock is used in user, bh and irq
 * context, so when taken outside hardirq context it should always be
 * taken with interrupts disabled.  The lock protects both the
 * hardware and the struct wlandevice.
 *
 * Another flag, wlandev->hw_unavailable indicates that the hardware is
 * unavailable for an extended period of time (e.g. suspended, or in
 * the middle of a hard reset).  This flag is protected by the
 * spinlock.  All code which touches the hardware should check the
 * flag after taking the lock, and if it is set, give up on whatever
 * they are doing and drop the lock again.  The acx100_lock()
 * function handles this (it unlocks and returns -EBUSY if
 * hw_unavailable is true). */

/*================================================================*/
/* System Includes */

#include <linux/config.h>
#define WLAN_DBVAR	prism2_debug
#include <linux/version.h>

#include <linux/module.h>
#include <linux/kernel.h>

#include <linux/sched.h>
#include <linux/types.h>
#include <linux/skbuff.h>
#include <linux/slab.h>
#include <linux/proc_fs.h>
#include <linux/if_arp.h>
#include <linux/rtnetlink.h>
#include <linux/wireless.h>
#include <linux/netdevice.h>
#include <asm/io.h>
#include <linux/delay.h>
#include <asm/byteorder.h>
#include <asm/bitops.h>
#include <asm/uaccess.h>

#include <wlan_compat.h>

#include <linux/ioport.h>
#include <linux/pci.h>

#include <asm/pci.h>
#include <linux/dcache.h>
#include <linux/highmem.h>
#include <linux/sched.h>
#include <linux/skbuff.h>
#include <linux/etherdevice.h>

/*================================================================*/
/* Project Includes */

#include <version.h>
#include <p80211hdr.h>
#include <p80211mgmt.h>
#include <p80211msg.h>
#include <p80211ioctl.h>
#include <acx100.h>
#include <p80211conv.h>
#include <p80211netdev.h>
#include <p80211req.h>
#include <p80211types.h>
#include <acx100_helper.h>
#include <acx100_helper2.h>
#include <idma.h>
#include <ihw.h>
#include <acx100mgmt.h>

/********************************************************************/
/* Module information                                               */
/********************************************************************/

MODULE_AUTHOR("The ACX100 Open Source Driver development team");
MODULE_DESCRIPTION("Driver for TI ACX100 based wireless cards");
#ifdef MODULE_LICENSE
MODULE_LICENSE("Dual MPL/GPL");
#endif

/*================================================================*/
/* Local Constants */

#define PCI_TYPE		(PCI_USES_MEM | PCI_ADDR0 | PCI_NO_ACPI_WAKE)
#define PCI_SIZE		0x1000	/* Memory size - 4K bytes */
#define PCI_SIZE2   0x10000

/* ACX100 22Mb/s WLAN controller */
#define PCI_VENDOR_ID_TI		0x104c
#define PCI_DEVICE_ID_TI_ACX100		0x8400
#define PCI_DEVICE_ID_TI_ACX100_CB	0x8401

/* PCI Class & Sub-Class code, Network-'Other controller' */
#define PCI_CLASS_NETWORK_OTHERS 0x280


/*================================================================*/
/* Local Macros */

/*================================================================*/
/* Local Types */

/*================================================================*/
/* Local Static Definitions */
#define DRIVER_SUFFIX	"_pci"
#define MAX_WLAN_DEVICES 4
#define CARD_EEPROM_ID_SIZE 6
#define CARD_EEPROM_ID	"Global"
unsigned char broken_SS1021_ID[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

typedef char *dev_info_t;
static char *version = "TI acx100" DRIVER_SUFFIX ".o: " WLAN_RELEASE;
static char *shortversion = WLAN_RELEASE_SUB;
static dev_info_t dev_info = "TI acx100" DRIVER_SUFFIX;

int debug = 0x9b;
int use_eth_name = 0;

static struct pci_device_id pci_id_tbl[] = {
	{
	 PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_ACX100,
	 PCI_ANY_ID, PCI_ANY_ID,
	 0, 0,
	 /* Driver data, we just put the name here */
	 (unsigned long)
	 "Texas Instruments ACX 100 22Mbps Wireless Interface"},
	{
	 PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_ACX100_CB,
	 PCI_ANY_ID, PCI_ANY_ID,
	 0, 0,
	 /* Driver data, we just put the name here */
	 (unsigned long)
	 "Texas Instruments ACX 100 22Mbps Wireless Interface"},
	{
	 0, 0, 0, 0, 0, 0, 0}
};

MODULE_DEVICE_TABLE(pci, pci_id_tbl);

static int acx100_probe_pci(struct pci_dev *pdev,
			    const struct pci_device_id *id);
static void acx100_remove_pci(struct pci_dev *pdev);



struct pci_driver acx100_pci_drv_id = {
	.name        = "acx100_pci",
	.id_table    = pci_id_tbl,
	.probe       = acx100_probe_pci,
	.remove      = __devexit_p(acx100_remove_pci),
};

const long acx100_channel_freq[] = {
	2412, 2417, 2422, 2427, 2432, 2437, 2442,
	2447, 2452, 2457, 2462, 2467, 2472, 2484
};

UINT8 link_rate, link_rx_flow;

typedef struct acx100_device {
	netdevice_t *next;
} acx100_device_t;

static struct acx100_device root_acx100_dev = {
	.next        = NULL,
};

static int acx100_start_xmit(struct sk_buff *skb, netdevice_t * dev);
static void acx100_tx_timeout(netdevice_t * dev);
static struct net_device_stats *acx100_get_stats(netdevice_t * wlandev);
static struct iw_statistics *acx100_get_wireless_stats(netdevice_t * wlandev);
static int acx100_ioctl(netdevice_t * dev, struct ifreq *ifr, int cmd);
static irqreturn_t acx100_interrupt(int irq, void *dev_id, struct pt_regs *regs);
static void set_rx_mode(netdevice_t * netdev);
void acx100_rx(wlan_pb_t * p80211, wlandevice_t * wlandev);
int init_module(void);
void cleanup_module(void);


static int acx100_open(netdevice_t * dev);
static int acx100_close(netdevice_t * dev);
static void acx100_up(netdevice_t * dev);
static void acx100_down(netdevice_t * dev);

/*----------------------------------------------------------------
* acx100_probe_pci
*
* Probe routine called when a PCI device w/ matching ID is found.
* The ISL3874 implementation uses the following map:
*   BAR0: Prism2.x registers memory mapped, size=4k
* Here's the sequence:
*   - Allocate the PCI resources.
*   - Read the PCMCIA attribute memory to make sure we have a WLAN card
*   - Reset the MAC
*   - Initialize the netdev and wlan data
*   - Initialize the MAC
*
* Arguments:
*	pdev		ptr to pci device structure containing info about
*			pci configuration.
*	id		ptr to the device id entry that matched this device.
*
* Returns:
*	zero		- success
*	negative	- failed
*
* Side effects:
*
*
* Call context:
*	process thread
*
* STATUS: should be pretty much ok. UNVERIFIED.
*
* Comment: The function was rewritten according to the V3 driver.
*	The debugging information from V1 is left even if
*	absent from V3.
----------------------------------------------------------------*/
static int __init
acx100_probe_pci(struct pci_dev *pdev, const struct pci_device_id *id)
{
	int result;
	int err;

	unsigned long phymem1;
	unsigned long phymem2;
	unsigned long mem1 = 0;
	unsigned long mem2 = 0;

	wlandevice_t *wlandev = 0;
	struct net_device *netdev = 0;

	unsigned char buffer[CARD_EEPROM_ID_SIZE];
	unsigned char charbuf;
	int i;
	struct {
		UINT16 vala;
		UINT16 valb;
		char fw_id[20];
		UINT32 val0x14;
	} fw;
	unsigned char radio_type;
	char *radio_str;
	char *devname_mask;

	FN_ENTER;

	/* Enable the PCI device */
	if (pci_enable_device(pdev) != 0) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: %s: pci_enable_device() failed\n",
		       dev_info);
		result = -EIO;
		goto fail;
	}

	/* enable busmastering (required for CardBus) */
	pci_set_master(pdev);
#if DOES_NOT_WORK
	/* on my Dell Inspiron 8000, if I try to suspend it,
	 * the notebook immediately resumes after shutdown when my
	 * ACX100 mini-PCI card is installed. This is obviously not useful :-(
	 * Thus I'm trying to fix this severe problem by playing with
	 * PCI power management bits. So far it's not very successful
	 * :-\
	 */
	acxlog(L_DEBUG, "wake: %d\n", pci_enable_wake(pdev, 0, 0));
#endif

	/* Figure out our resources */
	phymem1 = pci_resource_start(pdev, 1);
	phymem2 = pci_resource_start(pdev, 2);

	if (!request_mem_region
	    (phymem1, pci_resource_len(pdev, 1), "Acx100_1")) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: acx100: Cannot reserve PCI memory region 1\n");
		result = -EIO;
		goto fail;
	}

	if (!request_mem_region
	    (phymem2, pci_resource_len(pdev, 2), "Acx100_2")) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: acx100: Cannot reserve PCI memory region 2\n");
		result = -EIO;
		goto fail;
	}

	mem1 = (unsigned long) ioremap(phymem1, PCI_SIZE);
	if (mem1 == 0) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: %s: ioremap() failed.\n",
		       dev_info);
		result = -EIO;
		goto fail;
	}

	mem2 = (unsigned long) ioremap(phymem2, PCI_SIZE2);
	if (mem2 == 0) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: %s: ioremap() failed.\n",
		       dev_info);
		result = -EIO;
		goto fail;
	}

	/* Log the device */
	acxlog(L_BINSTD | L_INIT,
	       "A Acx100 PCI device found, phymem1:0x%x, phymem2:0x%x, irq:%d, mem1:0x%x, mem2:0x%x\n",
	       (unsigned int) phymem1, (unsigned int) phymem2, pdev->irq,
	       (unsigned int) mem1, (unsigned int) mem2);

	if ((wlandev = kmalloc(sizeof(wlandevice_t), GFP_KERNEL)) == NULL) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: %s: Memory allocation failure\n",
		       dev_info);
		result = -EIO;
		goto fail;
	}

	memset(wlandev, 0, sizeof(wlandevice_t));

	wlandev->membase = phymem1;
	wlandev->iobase = mem1;
	wlandev->pvMemBaseAddr1 = mem1;

	wlandev->membase2 = phymem2;
	wlandev->iobase2 = mem2;
	wlandev->pvMemBaseAddr2 = mem2;

	spin_lock_init(&wlandev->lock);

#if (DRIVER_VERSION & (V3|RELAXED_CODE))
	/* Check the card ( V1_3CHANGE ) */
	memset(&buffer, 0, CARD_EEPROM_ID_SIZE);
	for (i = 0; i < CARD_EEPROM_ID_SIZE; i++) {
		/* NONBINARY: The loop could be optimized by avoiding the "add"
		   "ACX100_EEPROM_ID_OFFSET + i" at each iteration */
		acx100_check_eeprom_name(wlandev,
					 ACX100_EEPROM_ID_OFFSET + i,
					 &charbuf);
		buffer[i] = charbuf;
	}
	if (memcmp(&buffer, CARD_EEPROM_ID, CARD_EEPROM_ID_SIZE)) {
		if (!memcmp(&buffer, broken_SS1021_ID, CARD_EEPROM_ID_SIZE))
		{
			acxlog(L_STD, "acx100_probe_pci: EEPROM card ID string check found uninitialised card ID: is this a SpeedStream SS1021??\n");
		}
		else
		{
			acxlog(L_STD,
		       "acx100_probe_pci: EEPROM card ID string check found unknown card: expected %s, got %.*s! Please report!\n",
		       CARD_EEPROM_ID, CARD_EEPROM_ID_SIZE, buffer);
			/*
			 * Don't do this any more, since there seem to be some
			 * "broken" cards around which don't have a proper ID
			result = -EIO;
			goto fail;
			*/
		}
	}
#endif

	if ((netdev = kmalloc(sizeof(netdevice_t), GFP_ATOMIC)) == NULL) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: Failed to alloc netdev\n");
		result = -EIO;
		goto fail;
	}

	memset(netdev, 0, sizeof(netdevice_t));
	ether_setup(netdev);

	/* now we have our device, so make sure the kernel doesn't try
	 * to send packets even though we're not associated to a network yet */
	acxlog(L_XFER, "stop queue after setup.\n");
	netif_stop_queue(netdev);

	netdev->priv = wlandev;
	wlandev->next_nd = root_acx100_dev.next;
	wlandev->netdev = root_acx100_dev.next = netdev;

	if (pdev->irq == 0) {
		acxlog(L_BINSTD | L_IRQ | L_INIT,
		       "acx100_probe_pci: %s: Can't get IRQ %d\n",
		       dev_info, 0);
		result = -EIO;
		goto fail;
	}

	netdev->irq = pdev->irq;
	netdev->base_addr = pci_resource_start(pdev, 0);

	if (!acx100_reset_dev(netdev)) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: %s: MAC initialize failure!\n",
		       dev_info);
		result = -EIO;
		goto fail;
	}

	devname_mask = (use_eth_name) ? "eth%d" : "wlan%d";
	if (dev_alloc_name(netdev, devname_mask) < 0)
	{
		result = -EIO;
		goto fail;
	}

	netdev->open = &acx100_open;
	netdev->stop = &acx100_close;
	netdev->hard_start_xmit = &acx100_start_xmit;
	netdev->get_stats = &acx100_get_stats;
	netdev->get_wireless_stats = &acx100_get_wireless_stats;
	netdev->do_ioctl = &acx100_ioctl;
	netdev->set_multicast_list = &set_rx_mode;
	netdev->tx_timeout = &acx100_tx_timeout;
	netdev->watchdog_timeo = 4 * HZ;	/* 400 */

	if ((err = register_netdev(netdev)) != 0) {
		acxlog(L_BINSTD | L_INIT,
		       "acx100_probe_pci: %s: Register net device of %s failed: %d\n\n",
		       dev_info, netdev->name, err);
		result = -EIO;
		goto fail;
	}
	if (acx100_init_mac(netdev)) {
		acxlog(L_DEBUG | L_INIT,
		       "Danger Will Robinson, MAC did not come back\n");
		result = -EIO;
		goto fail;
	}

	radio_type = hwReadRegister16(wlandev, 0x2ac) >> 8;

	switch(radio_type) {
		case 0x11:
			radio_str = "RFMD";
			break;
		case 0x0d:
			/* hmm, the DWL-650+ seems to have two variants,
			 * according to a windows driver changelog comment:
			 * RFMD and Maxim. */
			radio_str = "Maxim";
			break;
		default:
			radio_str = "UNKNOWN, please report the radio type name!";
			break;
	}

	/* needs to be after acx100_init_mac() due to necessary init stuff */
	ctlFWRevRead(wlandev, (memmap_t *)&fw);

	acxlog(L_STD, "acx100: radio type 0x%02x (%s). Uploaded firmware '%s' (0x%08lx).\n", radio_type, radio_str, fw.fw_id, fw.val0x14);

	pci_set_drvdata(pdev, netdev);
	result = 0;
	goto done;

      fail:
	if (netdev)
		kfree(netdev);
	if (wlandev)
		kfree(wlandev);
	if (mem1)
		iounmap((void *) mem1);
	if (mem2)
		iounmap((void *) mem2);

	/* NONBIN_DONE: V3 failed to release_mem_region on failure,
	 * causing subsequent driver loading to fail!! */
	release_mem_region(pci_resource_start(pdev, 1),
			   pci_resource_len(pdev, 1));

	release_mem_region(pci_resource_start(pdev, 2),
			   pci_resource_len(pdev, 2));

      done:
	FN_EXIT(1, result);
	return result;
}				/* acx100_probe_pci() */


/*----------------------------------------------------------------
* acx100_remove_pci
*
* Deallocate PCI resources for the ACX100 chip.
*
* Arguments:
*	pdev		ptr to pci device structure containing info about
*			pci configuration.
*
* Returns:
*	nothing
*
* Side effects:
*
* Call context:
*	process thread
*
* STATUS: should be pretty much ok. UNVERIFIED.
*
* Comment: The function was rewritten according to the V3 driver.
----------------------------------------------------------------*/
void __exit acx100_remove_pci(struct pci_dev *pdev)
{
	struct net_device *netdev;
	wlandevice_t *wlandev;
	struct net_device *currdev;
	struct net_device *nextdev;
	struct net_device *prevdev;

	DBFENTER;

	netdev = (struct net_device *) pci_get_drvdata(pdev);
	wlandev = (struct wlandevice *) netdev->priv;
	currdev = (struct net_device *) root_acx100_dev.next;
	prevdev = NULL;

	while (currdev != NULL) {
		nextdev = ((struct wlandevice *) currdev->priv)->next_nd;
		if (strcmp(currdev->name, netdev->name) == 0) {
			if (prevdev == NULL) {
				root_acx100_dev.next = nextdev;
			} else {
				((struct wlandevice *) prevdev->priv)->
				    next_nd = nextdev;
			}
			break;
		}
		prevdev = currdev;
		currdev = nextdev;
	}

	if (currdev && currdev->priv) {
		netif_device_detach(currdev);

		if (wlandev->state != 1)
			acx100_down(netdev);

		/* What does the following masks mean ?
		 * Are there symbolic names ? */
		wlandev->state = ((wlandev->state & 0xfe) | 0x2);
	}

	dmaDeleteDC(wlandev);
	unregister_netdev(netdev);
	iounmap((void *) wlandev->iobase);
	iounmap((void *) wlandev->iobase2);
	if (wlandev)
		kfree(wlandev);

	if (netdev)
		kfree(netdev);

	release_mem_region(pci_resource_start(pdev, 1),
			   pci_resource_len(pdev, 1));

	release_mem_region(pci_resource_start(pdev, 2),
			   pci_resource_len(pdev, 2));

	pci_set_drvdata(pdev, NULL);
	acxlog(L_BINSTD | L_INIT, "Device %s removed!\n", netdev->name);

	DBFEXIT;
}


/* acx100_up() - 
 * STATUS: should really be ok. 
 */
static void acx100_up(netdevice_t * dev)
{
	wlandevice_t *wlandev = (wlandevice_t *) dev->priv;
	hwEnableISR(wlandev);
	acx100_start(wlandev);
//      acx100_init_mac(hw);
}

/* acx100_down() - 
 * STATUS: should really be ok. 
 */
static void acx100_down(netdevice_t * dev)
{
	wlandevice_t *wlandev = (wlandevice_t *) dev->priv;
	FN_ENTER;
	hwDisableISR(wlandev);
	FN_EXIT(0, 0);
}


/*----------------------------------------------------------------
* acx100_open
*
* WLAN device open method.  Called from p80211netdev when kernel
* device open (start) method is called in response to the
* SIOCSIFFLAGS ioctl changing the flags bit IFF_UP
* from clear to set.
*
* Arguments:
*	wlandev		wlan device structure
*
* Returns:
*	0	success
*	>0	f/w reported error
*	<0	driver reported error
*
* Side effects:
*
* Call context:
*	process thread
* STATUS: should be ok.
----------------------------------------------------------------*/

static int acx100_open(netdevice_t * ndev)
{
	wlandevice_t *dev = (wlandevice_t *) ndev->priv;
	int result;

	FN_ENTER;
	if (dev->state & 0x2) {
		acxlog(L_BINSTD | L_INIT, "No such device\n");
		result = -ENODEV;
		goto done;
	}
	/* request shared IRQ handler */
	if (request_irq(ndev->irq, acx100_interrupt, SA_SHIRQ, ndev->name, ndev)) {
		acxlog(L_BINSTD | L_INIT | L_IRQ, "request_irq failed\n");
		result = -EAGAIN;
		goto done;
	}
	acx100_up(ndev);


#if (DRIVER_VERSION & V1)
	/* V1_3CHANGE: code part used in V1 only */
	acxlog(L_IRQ, "Test interrupt at %d\n", ndev->irq);
#ifndef USE_EQUIVALENT
	writel(0xffff, dev->iobase + 0xb0);
#else
	hwWriteRegister16(dev, ACX100_IRQ_SOMETHING, 0xffff);
#endif
	acxlog(L_IRQ, "ACX100 card at IRQ : %d\n", ndev->irq);
#endif

	dev->state |= 0x1;
	/* FIXME: we should get the device reinitialized here.
	acxlog(L_XFER, "start queue during open.\n");
	netif_start_queue(ndev);
	*/

	WLAN_MOD_INC_USE_COUNT;
	result = 0;

	/* We don't currently have to do anything else.
	 * The setup of the MAC should be subsequently completed via
	 * the mlme commands.
	 * Higher layers know we're ready from dev->start==1 and
	 * dev->tbusy==0.  Our rx path knows to pass up received/
	 * frames because of dev->flags&IFF_UP is true.
	 */
      done:
	FN_EXIT(1, result);
	return result;
}

/*----------------------------------------------------------------
* acx100_close
*
* WLAN device close method.  Called from p80211netdev when kernel
* device close method is called in response to the
* SIOCSIIFFLAGS ioctl changing the flags bit IFF_UP
* from set to clear.
*
* Arguments:
*	wlandev		wlan device structure
*
* Returns:
*	0	success
*	>0	f/w reported error
*	<0	driver reported error
*
* Side effects:
*
* Call context:
*	process thread
*
* STATUS: Should be pretty much perfect now.
----------------------------------------------------------------*/

static int acx100_close(netdevice_t * dev)
{
	wlandevice_t *hw = (wlandevice_t *) dev->priv;

	FN_ENTER;

	if (netif_device_present(dev)) {
		acxlog(L_XFER, "stop queue during close.\n");
		netif_stop_queue(dev);
		acx100_down(dev);
	}

	free_irq(dev->irq, dev);
	hw->val0x240c = 0;	// we'll call it status later
	WLAN_MOD_DEC_USE_COUNT;

	hw->state &= ~1;
	/* We don't currently have to do anything else.
	 * Higher layers know we're not ready from dev->start==0 and
	 * dev->tbusy==1.  Our rx path knows to not pass up received
	 * frames because of dev->flags&IFF_UP is false.
	 */

	FN_EXIT(0, 0);
	return 0;
}

/* acx100_start_xmit()
 * STATUS: UNVERIFIED.
 */
static int acx100_start_xmit(struct sk_buff *skb, netdevice_t * dev)
{
	int txresult;
//	unsigned long flags;
	wlandevice_t *wlandev = (wlandevice_t *) dev->priv;
	wlan_pb_t *pb;
	int templen;

	acxlog(L_STATE, "%s: UNVERIFIED.\n", __func__);
	if (!skb) {
		return 0;
	}
	if (!wlandev) {
		return 1;
	}
	if (!(wlandev->state & 1)) {
		return 1;
	}

	if (wlandev->iStatus != ISTATUS_4_ASSOCIATED) {
		acxlog(L_ASSOC,
		       "Strange: trying to xmit, but not associated yet: aborting...\n");
		return 1;
	}

	if (netif_queue_stopped(dev)) {
		// V1 code
		acxlog(L_BINSTD,
		       "acx100_start_xmit: called when queue stopped\n");
		return 1;
	}
	/* we're going to transmit now, so stop another packet from entering */
	acxlog(L_XFER, "stop queue during Tx.\n");
	netif_stop_queue(dev);
//	acx100_lock(wlandev,&flags);

	if (!(pb = p80211pb_alloc())) {
		return 1;
	}
	memset(pb, 0, sizeof(wlan_pb_t) /*0x14*4 */ );

	pb->ethhostbuf = skb;
	pb->ethbuf = skb->data;
	templen = skb->len;
	if (templen > ETH_FRAME_LEN) {
		templen = ETH_FRAME_LEN;
	}
	pb->ethbuflen = templen;
	pb->ethfrmlen = templen;

	pb->eth_hdr = (wlan_ethhdr_t *) pb->ethbuf;

	// FISHY: This is called TWICE in assembler !
	if (p80211pb_ether_to_p80211(wlandev, pb)) {
		txresult = 1; //this is bad, bad, bad
			//read linux/Documentation/networking/driver.txt
	} else {
		acxlog(L_XFER, "calling dmaTxData\n");
		txresult = dmaTxData(wlandev, pb);
		if (txresult == 1){
//			acx100_unlock(wlandev,&flags);
			return 1;
		}
		acxlog(L_XFER, "wake queue for future Tx.\n");
		netif_wake_queue(dev);
		wlandev->stats.tx_packets++;
		wlandev->stats.tx_bytes += skb->len;

		if (pb->p80211hostbuf != NULL)
			kfree(pb->p80211hostbuf);

		if (pb->ethhostbuf != NULL) {
			if ((atomic_read(&skb->users) == 1)
			    || (atomic_dec_and_test(&skb->users) == 0))
				kfree_skb(skb);
		}

		if (pb != NULL)
			kfree(pb);
	dev->trans_start = jiffies;
	}
//	acx100_unlock(wlandev,&flags);

	FN_EXIT(1, txresult);
	return txresult;
}

/* acx100_tx_timeout()
 * STATUS: ok.
 */
static void acx100_tx_timeout(netdevice_t * dev)
{
//	char tmp[4];
/*	dev->trans_start = jiffies;
	netif_wake_queue(dev);
*/

//	ctlCmdFlushTxQueue((wlandevice_t*)dev->priv,(memmap_t*)&tmp);
	FN_ENTER;

}


/* acx100_get_stats()
 * STATUS: should be ok..
 */
static struct net_device_stats *acx100_get_stats(netdevice_t * dev)
{
#if HACK
	return NULL;
#endif
	return &((wlandevice_t *) dev->priv)->stats;
}

static struct iw_statistics *acx100_get_wireless_stats(netdevice_t *dev)
{
	wlandevice_t *wlandev = (wlandevice_t *)dev->priv;

	return &wlandev->wstats;
}

/* acx100_ioctl_get_iw_priv()
 * STATUS: not checked, but works for now.
 */
static inline int acx100_ioctl_get_iw_priv(struct iwreq *iwr)
{
	/* NONBINARY : I added the monitor mode and changed the stuff below to look more like the orinoco driver */
	static struct iw_priv_args iwp[] = {
	      {cmd:SIOCIWFIRSTPRIV + 0x0,
		      set_args:0,
		      get_args:0,
	      name:"DUMMY;-)"},
	      {cmd:SIOCIWFIRSTPRIV + 0x1,
		      set_args:IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
		      get_args:0,
	      name:"monitor"},
    { cmd : SIOCIWFIRSTPRIV + 0x2,
		  set_args : 0,
		  get_args : 0,
		  name : "fw"},
    { cmd : SIOCIWFIRSTPRIV + 0x3,
		  set_args : 0,
		  get_args : 0,
		  name : "test"},
    { cmd : SIOCIWFIRSTPRIV + 0x4,
		  set_args : 0,
		  get_args : 0,
		  name : "get_antenna"},
    { cmd : SIOCIWFIRSTPRIV + 0x5,
		  set_args : IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
		  get_args : 0,
		  name : "set_antenna"},
    { cmd : SIOCIWFIRSTPRIV + 0x6,
		  set_args : IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
		  get_args : 0,
		  name : "set_debug"},
    { cmd : SIOCIWFIRSTPRIV + 0x7,
		  set_args : IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
		  get_args : 0,
		  name : "set_ed"},
    { cmd : SIOCIWFIRSTPRIV + 0x8,
		  set_args : IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
		  get_args : 0,
		  name : "set_cca"},
    { cmd : SIOCIWFIRSTPRIV + 0x9,
		  set_args : 0,
		  get_args : 0,
		  name : "list_reg_domain"},
    { cmd : SIOCIWFIRSTPRIV + 0xa,
		  set_args : 0,
		  get_args : IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,
		  name : "get_reg_domain"},
    { cmd : SIOCIWFIRSTPRIV + 0xb,
		  set_args : IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,
		  get_args : 0,
		  name : "set_reg_domain"}
	};
	int result = 0;

	if (iwr->u.data.pointer != 0) {
		result =
		    verify_area(VERIFY_WRITE, iwr->u.data.pointer,
				sizeof(iwp));
		if (result != 0)
			return result;

		/* FIXME: this is perhaps not in asm like that, but it's
		 * required to make it work for now.
		 */
		iwr->u.data.length = sizeof(iwp) / sizeof(iwp[0]);
		if (copy_to_user(iwr->u.data.pointer, iwp, sizeof(iwp)) !=
		    0)
			result = -EFAULT;
	}
	return result;
}
static inline int acx100_ioctl_get_nick(wlandevice_t *wlandev, struct 
			iw_point *ip)
{
	/* copied from orinoco.c */
	char nickbuf[IW_ESSID_MAX_SIZE+1];

/* consider spinlock here */
	memcpy(nickbuf,wlandev->nick,IW_ESSID_MAX_SIZE+1);
/* consider spinlock here */

	ip->length = strlen(nickbuf)+1;

	if (copy_to_user(ip->pointer,nickbuf,sizeof(nickbuf)))
		return -EFAULT;
	
	return 0;
}
static inline int acx100_ioctl_set_nick(wlandevice_t *wlandev, struct 
			iw_point *ip)
{
	/* copied from orinoco.c */
	char nickbuf[IW_ESSID_MAX_SIZE+1];

	if(ip->length > IW_ESSID_MAX_SIZE)
		return -E2BIG;

	memset(nickbuf,0,sizeof(nickbuf));

	if (copy_from_user(nickbuf,ip->pointer,ip->length))
		return -EFAULT;

/* consider spinlock here */
	memcpy(wlandev->nick,nickbuf,sizeof(wlandev->nick));
/* consider spinlock here */

		
	return 0;
}
static inline int acx100_ioctl_get_fw_stats(wlandevice_t *wlandev)
{
	//UINT tmp[(ACX100_RID_FIRMWARE_STATISTICS_LEN + 8)/4];
	struct {
	UINT val0x0;
	UINT val0x4[6];
	UINT processed_rx1;//val0x1c
	UINT processed_rx2;//val0x20
	UINT val0x24;
	UINT processed_tx1;//val0x28
	UINT val0x2c[2];
	UINT total_rx;//val0x34
	UINT unprocessed_rx1;//val0x38
	UINT unprocessed_rx2;//val0x3c
	UINT val0x40[3];
	UINT processed_tx2;//val0x48
	UINT val0x4c[0x2];
	UINT unprocessed_tx1; //val0x50
	UINT unprocessed_tx2; //val0x54
	UINT val0x5c[0x10];
	
	}tmp;
	int i;
	ctlFirmwareStatisticsRead(wlandev,(memmap_t*)&tmp);
	for (i = 1; i < 6 ; i++)
		printk("%6d ",tmp.val0x4[i]);
	printk("\n");
	for (i = 0; i < 2 ; i++)
		printk("%6d ",tmp.val0x2c[i]);
	printk("\n");

	for (i = 0; i < 3 ; i++)
		printk("%6d ",tmp.val0x40[i]);
	printk("\n");
	for (i = 0; i < 2 ; i++)
		printk("%6d ",tmp.val0x4c[i]);
	printk("\n");
	for (i = 0; i < 0x10 ; i++){
		printk("%6d ",tmp.val0x5c[i]);
		if(i%8 == 0)
			printk("\n");
		}

	printk("\n"); 
	printk("processed RX : %d, %d\n",
/* wlandev->rx_ps, */
		tmp.processed_rx1,
		tmp.processed_rx2);
	printk("unprocessed RX : %d, %d\n",
		tmp.unprocessed_rx1,
		tmp.unprocessed_rx2);
	printk("Rxed DataPackets: %d\n",tmp.total_rx-tmp.processed_rx1);
	printk("processed TX : %d %d\n",
/* wlandev->tx_ps, */
		tmp.processed_tx1,
		tmp.processed_tx2
/*		wlandev->tx_ps2,
		wlandev->tx_ps3 */
		);
	printk("unprocessed TX : %d, %d\n",
		tmp.unprocessed_tx1,
		tmp.unprocessed_tx2);
/*	printk("Bytes in: %d\n",wlandev->rx_ps_size);
	printk("Bytes out: %d\n",wlandev->tx_ps_size);
*/	

	return 0;
}
static inline int acx100_ioctl_unknown11(wlandevice_t *wlandev)
{
//	UINT16 tmp[(ACX100_RID_MEDIUM_USAGE_LEN+4)/2];
	struct tmp {
	UINT16 type;
	UINT16 status;
	UINT8 val0x4;
	UINT8 val0x5;
	UINT16 val0x6;
	UINT8 val0x8;
	UINT8 val0x9;
	UINT16 val0xa;
	} tmp;
//	int i;
//	memset(tmp,0xffffffff,0x9c);
//	ctlConfigOptionsRead(wlandev,(memmap_t*)tmp);
	ctlMediumUsageRead(wlandev,(memmap_t*)&tmp);
/*	for (i = 0; i <(ACX100_RID_MEDIUM_USAGE_LEN+4)/2  ; i++){
		printk("%6d ",tmp[i]);
		if(i%16 == 15)
			printk("\n");
	}
*/
	printk("%3d %3d %3d %3d %3d %3d\n", tmp.val0x4,tmp.val0x5,
		tmp.val0x6,tmp.val0x8,tmp.val0x9,tmp.val0xa);

	return 0;
}

static inline int acx100_ioctl_wlansniff(wlandevice_t *wlandev, struct iwreq *iwr)
{
	int *parms = (int*) iwr->u.name;
	int enable = parms[0] > 0;
	
	wlandev->monitor = parms[0];
	
	switch (parms[0])
	{
	case 0:
		wlandev->netdev->type = ARPHRD_ETHER;
		break;
	case 1:
		wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
		break;
	case 2:
		wlandev->netdev->type = ARPHRD_IEEE80211;
		break;
	}
	
	acx100_set_rxconfig(wlandev);

	if (enable)
	{
		wlandev->channel = parms[1];
		ctlCmdEnableRx(wlandev, wlandev->channel);
	}
	
	return 0;
}

static inline int acx100_ioctl_get_antenna(wlandevice_t *wlandev)
{
	unsigned char antenna[0x5];

	memset(antenna, 0, sizeof(antenna));
	ctlDot11CurrentAntenna(wlandev, (memmap_t *) &antenna, 0);

	printk("current antenna value: 0x%02X\n", antenna[0x4]);
	printk("Rx antenna selection seems to be bit 6 (0x40)\n");
	printk("Tx antenna selection seems to be bit 5 (0x20)\n");
	return 0;
}

static inline int acx100_ioctl_set_antenna(wlandevice_t *wlandev, struct iwreq *iwr)
{
	unsigned char antenna[4 + ACX100_RID_DOT11_CURRENT_ANTENNA_LEN];
	int val = *( (int *) iwr->u.name );

	memset(antenna, 0, sizeof(antenna));
	ctlDot11CurrentAntenna(wlandev, (memmap_t *) &antenna, 0);

	printk("current antenna value: 0x%02X\n", antenna[0x4]);
	printk("Rx antenna selection seems to be bit 6 (0x40)\n");
	printk("Tx antenna selection seems to be bit 5 (0x20)\n");
	antenna[0x4] = (unsigned char)val;
	printk("updated antenna value: 0x%02X\n", (unsigned char)val);
	ctlDot11CurrentAntenna(wlandev, (memmap_t *) &antenna, 1);
	return 0;
}

static inline int acx100_ioctl_set_ed_threshold(wlandevice_t *wlandev, struct iwreq *iwr)
{
	unsigned char ed_threshold[4 + ACX100_RID_DOT11_ED_THRESHOLD_LEN];
	int val = *( (int *) iwr->u.name );

	memset(ed_threshold, 0, sizeof(ed_threshold));

	ctlDot11EDThresholdRead(wlandev, (memmap_t *) &ed_threshold);
	printk ("current ED threshold value: 0x%02X\n", ed_threshold[0x4]);
	ed_threshold[0x4] = (unsigned char)val;
	printk ("updated ED threshold value: 0x%02X\n", (unsigned char)val);
        ctlDot11EDThresholdWrite(wlandev, (memmap_t *) &ed_threshold);
	return 0;
}

static inline int acx100_ioctl_set_cca(wlandevice_t *wlandev, struct iwreq *iwr)
{
	unsigned char cca[4 + ACX100_RID_DOT11_CURRENT_CCA_MODE_LEN];
	int val = *( (int *) iwr->u.name );

	memset(cca, 0, sizeof(cca));

	ctlDot11CurrentCCAModeRead(wlandev, (memmap_t *) &cca);
	printk ("current CCA value: 0x%02X\n", cca[0x4]);
	cca[0x4] = (unsigned char)val;
	printk ("updated CCA value: 0x%02X\n", (unsigned char)val);
        ctlDot11CurrentCCAModeWrite(wlandev, (memmap_t *) &cca);
	return 0;
}

static inline int acx100_ioctl_list_reg_domain(wlandevice_t *wlandev)
{
	printk("Domain/Country  Setting  Channels\n");
	printk("FCC (USA)          1       1-11\n");
	printk("DOC/IC (Canada)    2       1-11\n");
	printk("ETSI (Europe)      3       1-13\n");
	printk("Spain              4      10-11\n");
	printk("France             5      10-13\n");
	printk("MKK (Japan)        6       14\n");
	printk("MKK1               7       1-14\n");
	return 0;
}

static unsigned char reg_domains[] = {0x10, 0x20, 0x30, 0x31, 0x32, 0x40, 0x41};

static inline int acx100_ioctl_get_reg_domain(wlandevice_t *wlandev, struct iwreq *iwr)
{
	memmap_t dom;
	int val, i;

	ctlDot11CurrentRegDomainRead(wlandev, &dom);
	val = dom.m.gp.bytes[0];
	for (i=1; i <= 7; i++)
		if (reg_domains[i-1] == val)
		{
			acxlog(L_STD, "regulatory domain is currently set to %d (0x%x)\n", i, val);
			*(iwr->u.name) = i;
			break;
		}

	return 0;
}

static inline int acx100_ioctl_set_reg_domain(wlandevice_t *wlandev, struct iwreq *iwr)
{
	memmap_t dom;

	unsigned char val = *(iwr->u.name);

	if ((val < 1) || (val > 7))
		return -EINVAL;

	acxlog(L_STD, "setting regulatory domain to %d (0x%x)\n", val, reg_domains[val-1]);
	dom.m.gp.bytes[0] = reg_domains[val-1];
	ctlDot11CurrentRegDomainWrite(wlandev, &dom);

	return 0;
}

static inline int acx100_ioctl_set_debug(wlandevice_t *wlandev, struct iwreq *iwr)
{
	int val = *( (int *) iwr->u.name );

	acxlog(L_STD, "setting debug to 0x%04X\n", val);
	debug = val;
	return 0;
}

static inline int acx100_ioctl_getrate(wlandevice_t * wlandev,
				       struct iw_param *rrq)
{
	/* FIXME: maybe bitrateval is the value we *wanted*, but not the
	 * value it actually chose automatically. Needs verification and
	 * perhaps fixing. */
	rrq->value = wlandev->bitrateval * 100000;
	rrq->fixed = 2;		/* FIXME? */
	rrq->disabled = 0;
	return 0;
}

/* acx100_ioctl
 * STATUS: UNVERIFIED.
 * This overly huge and overly tabbed function should probably be split up
 * in separate inline'd functions per ioctl.
 */
static int acx100_ioctl(netdevice_t * dev, struct ifreq *ifr, int cmd)
{
	wlandevice_t *wlandev;
	int mult;
	int index;
	int channel;
	int result;
	int reinit;
	struct iwreq *iwr;
	
	wlandev = (wlandevice_t *) dev->priv;
	iwr = (struct iwreq *) ifr;
	reinit = 0;
	result = 0;
	mult = 1;
	channel = -1;

	acxlog(L_IOCTL|L_STATE, "<acx100_ioctl: UNVERIFIED. NONV3.> cmd = 0x%04X\n",
	       cmd);

	/* check to see whether we're up and running (whether
	 * acx100_open has been called). In other words: we need an
	 * "ifconfig wlan0 up" to continue here...
	 */
	if (!(wlandev->state & 1))
		return -ENODEV;

	switch (cmd) {

	case SIOCGIWNAME:
		/* get name == wireless protocol */
		acxlog(L_IOCTL, "Get Name => %s\n", shortversion);
		strcpy(iwr->u.name, shortversion);
		break;

	case SIOCSIWFREQ:
		/* set channel/frequency (Hz)
		   data can be frequency or channel :
		   0-1000 = channel
		   > 1000 = frequency in Hz */

		acxlog(L_IOCTL, "Set Frequency <= %i (%i)\n",
		       iwr->u.freq.m, iwr->u.freq.e);

		if (iwr->u.freq.e == 0 && iwr->u.freq.m <= 1000) {
			/* Setting by channel number */
			channel = iwr->u.freq.m;
		} else {
			/* If setting by frequency, convert to a channel */
			int i;

			for (i = 0; i < (6 - iwr->u.freq.e); i++)
				mult *= 10;

			for (i = 0; i <= 13; i++)
				if (iwr->u.freq.m ==
				    acx100_channel_freq[i] * mult)
					channel = i + 1;
		}

		if (channel > 14)
			return -EFAULT;

		if (wlandev->macmode == WLAN_MACMODE_ESS_AP /* 3 */ ) {
			wlandev->channel = channel;
			acxlog(L_IOCTL, "Changing to channel %d\n",
			       channel);
			ctlCmdEnableTx(wlandev, wlandev->channel);
			ctlCmdEnableRx(wlandev, wlandev->channel);
		} else if (wlandev->macmode == WLAN_MACMODE_ESS_STA	/* 2 */
			   || wlandev->macmode == WLAN_MACMODE_NONE /* 0 */ ) {

			/* do some essid stuff, which is useless, since
			 * AcxScanWithParam doesn't handle this
			 * parameter anyway!
			 * It seems more and more as if V3 was
			 * *experimenting* with essid things, since there
			 * are also some other code parts which copy
			 * an essid into nirvana. */
			struct myess {
				char id[0x20];
				UINT32 len;
			} myessid;
			struct channel chan;
#if V3_EXPERIMENTATION
			int len = strlen(wlandev->essid);	/* ebx */
			memcpy(myessid.id, wlandev->essid, len);

			/* FIXME: what is the purpose of this ?? I'm guessing that
			   it is because the string passed to the hardware is not null
			   terminated */
			if (wlandev->essid[len - 1] == '\0')
				len--;

			myessid.len = len;
#endif

			chan.val0x0 = 1;
			chan.channel = channel;
			chan.val0x4 = 0x8000;
			chan.val0x6 = 0x14;
			chan.val0x7 = 0x1;
			chan.val0x8 = 0x32;
			chan.val0xa = 0x64;
			acxlog(L_IOCTL, "Changing to channel %d\n",
			       channel);

			/* yep, struct chan gets passed directly via
			 * stack, not as pointer.
			 * NONBINARY: this is stupid; change
			 * AcxScanWithParam to pass pointer instead. */
			acx100_scan_chan_p(wlandev, (int *) &myessid, chan);
		}
#ifndef  HACK
		wlandev->channel = channel;
		/*This is the only way to get the channel to show up, so
		   far */
#endif

		reinit = 1;
		break;

	case SIOCGIWFREQ:
		/* get channel/frequency (Hz) */

		iwr->u.freq.e = 0;
		iwr->u.freq.m = wlandev->channel;
		break;

	case SIOCSIWMODE:
		/* set operation mode */

		acxlog(L_IOCTL, "Set Mode <= %i\n", iwr->u.mode);

		if (iwr->u.mode == IW_MODE_ADHOC)
			wlandev->mode = 0;
		else if (iwr->u.mode == IW_MODE_INFRA)
			wlandev->mode = 2;
		else
			return -EOPNOTSUPP;

		acx100_join_bssid(wlandev);
		break;

	case SIOCGIWMODE:
		acxlog(L_IOCTL, "Get Mode => %ld\n", wlandev->macmode);

		if (wlandev->macmode == WLAN_MACMODE_NONE /* 0 */ )
			iwr->u.mode = IW_MODE_ADHOC;
		else if (wlandev->macmode == WLAN_MACMODE_ESS_STA /* 2 */ )
			iwr->u.mode = IW_MODE_INFRA;
		break;

	case SIOCGIWAP:
		/* get access point MAC address */

		acxlog(L_IOCTL, "Get MAC address\n");
		/* as seen in Aironet driver, airo.c */
		memcpy(iwr->u.ap_addr.sa_data, wlandev->bssid, WLAN_BSSID_LEN);
		iwr->u.ap_addr.sa_family = ARPHRD_ETHER;
		break;


	case SIOCGIWAPLIST:
		/* get list of access points in range */

		if (wlandev->macmode != WLAN_MACMODE_ESS_AP /* 3 */ )
			return -EOPNOTSUPP;

		wlandev->unknown0x2350 = ISTATUS_5_UNKNOWN;
		acx100_scan_chan(wlandev, 0, 0);

		while (!(hwReadRegister16(wlandev, ACX100_STATUS) & 0x2000)) {
		};

		acxlog(L_IOCTL, "after site survey status = %d\n",
		       wlandev->iStatus);

		if (wlandev->iStatus == ISTATUS_5_UNKNOWN) {
			wlandev->iStatus = wlandev->unknown0x2350;
			wlandev->unknown0x2350 = 0;
		}

		if (iwr->u.data.flags == SIOCGIWAPLIST) {
			/* The variables being used in this ioctl,
			 * despite being localised in local brackets,
			 * still take up a lot of stack space,
			 * thus still possibly leading to IRQ handler
			 * stack overflow. They should probably be
			 * dynamically allocated instead. */
			struct ap {
				int size;
				char essid[32];
				int channel;
				char address[6];

				int var_71c;
				int var_718;
			} var_74c[IW_MAX_AP];

			int i = 0;

			if (wlandev->iStable != 0) {

				for (; i < wlandev->iStable; i++) {

					var_74c[i].channel =
					    wlandev->val0x126c[i].channel;
					var_74c[i].size =
					    wlandev->val0x126c[i].size;
					memcpy(&(var_74c[i].essid),
					       wlandev->val0x126c[i].essid,
					       var_74c[i].size);
					memcpy(var_74c[i].address,
					       wlandev->val0x126c[i].address,
					       WLAN_BSSID_LEN);

					var_74c[i].var_71c = ((wlandev->val0x126c[i].cap >> 1) ^ 1) & 1;	/* IBSS capability flag */
					var_74c[i].var_718 = wlandev->val0x126c[i].cap & 0x10;	/* Privacy/WEP capability flag */
				}
			}

			iwr->u.data.length =
			    wlandev->iStable * sizeof(struct ap);
			if (copy_to_user
			    (iwr->u.data.pointer, &var_74c,
			     iwr->u.data.length) != 0) {
				return -EFAULT;
			}

		} else if (iwr->u.data.pointer != 0) {

			struct ap_addr {
				sa_family_t sa_family;
				char sa_data[6];
			} var_94c[IW_MAX_AP];

			if (wlandev->iStable != 0) {

				int i;

				for (i = 0; i < wlandev->iStable; i++) {

					memcpy(var_94c[i].sa_data,
					       wlandev->val0x126c[i].address,
					       WLAN_BSSID_LEN);
					var_94c[i].sa_family = 1;	/* FIXME: AF_LOCAL ?? */
				}
			}


			iwr->u.data.length = wlandev->iStable;
			if (copy_to_user
			    (iwr->u.data.pointer, &var_94c,
			     wlandev->iStable * sizeof(struct ap_addr)) != 0) {
				return -EFAULT;
			}
		}
		break;

	case SIOCSIWESSID:
		/* set ESSID (network name) */

		acxlog(L_IOCTL, "Set Essid <= %s\n", iwr->u.data.pointer);

		{
			int len = iwr->u.data.length;

			if (len <= 0)
				break;

			len =
			    len >
			    WLAN_SSID_MAXLEN ? WLAN_SSID_MAXLEN : len;

			copy_from_user(wlandev->essid, iwr->u.essid.pointer,
				       len);
			reinit = 1;

			if ((wlandev->macmode == WLAN_MACMODE_ESS_STA /* 2 */ )
			    || (wlandev->macmode == WLAN_MACMODE_NONE /* 0 */ )) {
				char essid[WLAN_SSID_MAXLEN];

				int essid_len;

				memcpy(essid, wlandev->essid, len);

				if (wlandev->essid[len - 1] == '\0')
					len--;

				essid_len = len;
				acxlog(L_IOCTL,
				       "ssid len = %d, ssid = %s\n", len,
				       essid);
				acx100_scan_chan(wlandev, 0, essid_len);
			}
		}
		break;


	case SIOCGIWESSID:
		/* get ESSID */

		acxlog(L_IOCTL, "Get Essid => %s\n", wlandev->essid);

		iwr->u.essid.flags = 1;
		iwr->u.essid.length = strlen(wlandev->essid) + 1;
		copy_to_user(iwr->u.essid.pointer, wlandev->essid,
			     iwr->u.essid.length);
		break;


	case SIOCSIWRATE:
		/* set default bit rate (bps) */

		if (iwr->u.bitrate.fixed == 1) {

			switch (iwr->u.bitrate.value) {

			case 1000000:	/* 1Mbps */
				wlandev->bitrateval = 10;
				break;

			case 2000000:	/* 2Mbps */
				wlandev->bitrateval = 20;
				break;


			case 5500000:	/* 5.5Mbps */
				wlandev->bitrateval = 55;
				break;

			case 11000000:	/* 11Mbps */
				wlandev->bitrateval = 110;
				break;

			case 22000000:	/* 22Mbps */
				wlandev->bitrateval = 220;
				break;

			default:
				result = -EINVAL;
			}

		} else if (iwr->u.bitrate.fixed == 2) {

			switch (iwr->u.bitrate.value) {

			case 0:
				wlandev->bitrateval = 10;
				break;

			case 1:
				wlandev->bitrateval = 20;
				break;

			case 2:
				wlandev->bitrateval = 55;
				break;

			case 3:
				wlandev->bitrateval = 183;
				break;

			case 4:
				wlandev->bitrateval = 110;
				break;

			case 5:
				wlandev->bitrateval = 238;
				break;

			case 6:
				wlandev->bitrateval = 220;
				break;

			default:
				result = -EINVAL;
			}

		} else {

			result = -EOPNOTSUPP;

		}

		acxlog(L_IOCTL,
		       "rate = %d, fixed = 0x%x, disabled = 0x%x, flags = 0x%x\n",
		       iwr->u.bitrate.value, iwr->u.bitrate.fixed,
		       iwr->u.bitrate.disabled, iwr->u.bitrate.flags);

		acxlog(L_IOCTL, "Tx rate = %d\n", wlandev->bitrateval);
		break;

	case SIOCGIWRATE:
		result = acx100_ioctl_getrate(wlandev, &iwr->u.bitrate);
		break;

	case SIOCSIWENCODE:
		/* set encoding token & mode */

		acxlog(L_IOCTL,
		       "Set Encoding flags = %i, size = %i, key: %s\n",
		       iwr->u.encoding.flags, iwr->u.encoding.length,
		       iwr->u.encoding.pointer ? "set" : "No key");

		if (wlandev->macmode == WLAN_MACMODE_NONE /* 0 */ )
		{
			/* ok, let's pretend it's supported, but print a
			 * warning message */
			acxlog(L_STD, "Warning: WEP support might not be supported in Ad-Hoc mode yet!\n");
			/* return -EOPNOTSUPP; */
		}

		index = iwr->u.encoding.flags & IW_ENCODE_INDEX;

		if (iwr->u.encoding.length != 0) {

			struct {
				int pad;
				UINT8 val0x4;
				UINT8 val0x5;
				UINT8 val0x6;
				char key[29];
			} var_9ac;

			if (index == 0) {

				index = wlandev->current_index;

				if (iwr->u.encoding.length < 5)
					return -EINVAL;

				memset(wlandev->wep_keys[index].key, 0, 256);

				if (iwr->u.encoding.length < 13) {

					wlandev->wep_keys[index].size = 5; /* 5*8 == 40bit, WEP64 */
				} else if (iwr->u.encoding.length < 29) {

					wlandev->wep_keys[index].size = 13; /* 13*8 == 104bit, WEP128 */
				} else {

					wlandev->wep_keys[index].size = 29; /* 29*8 == 232, WEP256 */
				}
				copy_from_user(wlandev->wep_keys[index].key,
					       iwr->u.encoding.pointer,
					       wlandev->wep_keys[index].size);

			} else if (--index <= 3) {

				if (iwr->u.encoding.length < 5)
					return -EINVAL;

				memset(wlandev->wep_keys[index].key, 0, 256);
				wlandev->wep_keys[index].index = index;

				if (iwr->u.encoding.length < 13) {

					wlandev->wep_keys[index].size = 5; /* 5*8 == 40bit, WEP64 */

				} else if (iwr->u.encoding.length < 29) {

					wlandev->wep_keys[index].size = 13; /* 13*8 == 104bit, WEP128 */

				} else {

					wlandev->wep_keys[index].size = 29; /* 29*8 == 232, WEP256 */
				}
				copy_from_user(wlandev->wep_keys[index].key,
					       iwr->u.encoding.pointer,
					       wlandev->wep_keys[index].size);

			} else {

				return -EINVAL;
			}

			var_9ac.val0x4 = 1;
			var_9ac.val0x5 = wlandev->wep_keys[index].size;
			var_9ac.val0x6 = index;
			memcpy(var_9ac.key, wlandev->wep_keys[index].key,
			       var_9ac.val0x5);

			ctlDot11WEPDefaultKeyWrite(wlandev,
						   (memmap_t *) &var_9ac);

			wlandev->wep_enabled = 1;

		} else if (index == 0) {

			if (iwr->u.encoding.flags & IW_ENCODE_DISABLED)
				wlandev->wep_enabled = 0;
			
			if (iwr->u.encoding.flags & IW_ENCODE_OPEN) {

				wlandev->auth_alg = WLAN_AUTH_ALG_OPENSYSTEM;
				wlandev->wep_restricted = 0;

			} else if (iwr->u.encoding.
				   flags & IW_ENCODE_RESTRICTED) {

				wlandev->auth_alg = WLAN_AUTH_ALG_SHAREDKEY;
				wlandev->wep_restricted = 1;
			}

		} else if (--index <= 3) {
			memmap_t dkey;

			wlandev->current_index = index;
			dkey.m.dkey.num = wlandev->current_index;

			ctlDot11WEPDefaultKeySet(wlandev, &dkey);

		} else {

			return -EINVAL;
		}

		/* V3CHANGE: dbg msg not present */
		acxlog(L_IOCTL, "len = %d, key at 0x%p, flags = 0x%x\n",
		       iwr->u.encoding.length, iwr->u.encoding.pointer,
		       iwr->u.encoding.flags);

		for (index = 0; index <= 3; index++) {
			if (wlandev->wep_keys[index].size != 0)
				acxlog(L_IOCTL,
				       "index = %ld, size = %d, key at 0x%p\n",
				       wlandev->wep_keys[index].index,
				       wlandev->wep_keys[index].size,
				       wlandev->wep_keys[index].key);
		}

		break;

	case SIOCGIWENCODE:

		if (wlandev->macmode == WLAN_MACMODE_NONE /* 0 */ ) {
			/* ok, let's pretend it's supported, but print a
			 * warning message */
			acxlog(L_STD, "Warning: WEP support might not be supported in Ad-Hoc mode yet!\n");
			/* return -EOPNOTSUPP; */
		}

		/* set the current index */
		iwr->u.encoding.flags =
		    wlandev->wep_keys[wlandev->current_index].index + 1;

		if (wlandev->wep_enabled == 0)
		{
			iwr->u.encoding.flags |= IW_ENCODE_DISABLED;
		}
		else
		{
			iwr->u.encoding.length =
			    wlandev->wep_keys[wlandev->current_index].size;

			copy_to_user(iwr->u.encoding.pointer,
				     wlandev->wep_keys[wlandev->current_index].key,
				     wlandev->wep_keys[wlandev->current_index].size);
		}

		acxlog(L_IOCTL, "len = %d, key = %p, flags = 0x%x\n",
		       iwr->u.encoding.length, iwr->u.encoding.pointer,
		       iwr->u.encoding.flags);

		break;

	case SIOCGIWTXPOW:
		{
			/* FIXME: this should be in a nice subfunction :-) */
			memmap_t pow;
			struct iw_param *rrq = &iwr->u.txpower;
			char *txpow;
			int txpowval;

			ctlDot11CurrentTxPowerLevelRead(wlandev, &pow);

			if (pow.m.gp.bytes[0] == 1) {
				txpow = "16.5";
				txpowval = 16;
			} else {
				txpow = "18";
				txpowval = 18;
			}

			rrq->flags = IW_TXPOW_DBM;
			rrq->disabled = 0;
			rrq->fixed = 0;
			rrq->value = txpowval;

			acxlog(L_IOCTL, "Get transmit power => %s dBm\n",
			       txpow);
		}
		break;

	case SIOCSIWTXPOW:
		{
			memmap_t pow;
			struct iw_param *rrq = &iwr->u.txpower;
			char *txpow;

			/* Research indicates that the GL2422VP
			 * might have 16.5 dBm (45 mW) and 18 dBm (63 mW) */
			if (rrq->value < 18) {
				txpow = "16.5";
				pow.m.gp.bytes[0] = 1;
			} else {
				txpow = "18";
				pow.m.gp.bytes[0] = 2;
			}
			acxlog(L_IOCTL, "Set transmit power = %s dBm\n",
			       txpow);
			ctlDot11CurrentTxPowerLevelWrite(wlandev, &pow);
		}
		break;

	case SIOCGIWRANGE:
		/* Get range of parameters */

		if (iwr->u.data.pointer != NULL) {

			struct iw_range parm_range;

			iwr->u.data.length = sizeof(struct iw_range);
			memset(&parm_range, 0, sizeof(struct iw_range));

			parm_range.we_version_compiled = WIRELESS_EXT;
			parm_range.we_version_source = 0x9;
			parm_range.retry_capa = IW_RETRY_LIMIT;
			parm_range.retry_flags = IW_RETRY_LIMIT;
			parm_range.min_retry = IW_RETRY_LIMIT;

			if (copy_to_user
			    (iwr->u.data.pointer, &parm_range,
			     sizeof(struct iw_range)) != 0)
				result = -EFAULT;
		}
		break;


	case SIOCGIWPRIV:
		result = acx100_ioctl_get_iw_priv(iwr);
		break;

	case SIOCSIWNICKN:
		result = acx100_ioctl_set_nick(wlandev,&iwr->u.data);
		break;
	case SIOCGIWNICKN:
		result = acx100_ioctl_get_nick(wlandev,&iwr->u.data);
		break;
		/* NONBINARY: private functions */

	case SIOCIWFIRSTPRIV + 0x0:	/* DUMMY */
		acxlog(L_IOCTL, "%s: SIOCIWFIRSTPRIV + 0x0 (DUMMY)\n",
		       dev->name);
		break;

	case SIOCIWFIRSTPRIV + 0x1:	/* set sniff (monitor) mode */
		acxlog(L_IOCTL, "%s: SIOCIWFIRSTPRIV + 0x1 (monitor)\n",
		       dev->name);
		if (!capable(CAP_NET_ADMIN)) {
			result = -EPERM;
			break;
		}
// FIXME: implement this :)
    result = acx100_ioctl_wlansniff(wlandev, iwr);
		break;

  case SIOCIWFIRSTPRIV + 0x2:
		acx100_ioctl_get_fw_stats(wlandev);
		break;
  case SIOCIWFIRSTPRIV + 0x3:
		acx100_ioctl_unknown11(wlandev);
		break;
  case SIOCIWFIRSTPRIV + 0x4:
		acx100_ioctl_get_antenna(wlandev);
		break;
  case SIOCIWFIRSTPRIV + 0x5:
		acx100_ioctl_set_antenna(wlandev, iwr);
		break;
  case SIOCIWFIRSTPRIV + 0x6:
		acx100_ioctl_set_debug(wlandev, iwr);
		break;
  case SIOCIWFIRSTPRIV + 0x7:
		acx100_ioctl_set_ed_threshold(wlandev, iwr);
		break;
  case SIOCIWFIRSTPRIV + 0x8:
		acx100_ioctl_set_cca(wlandev, iwr);
		break;
  case SIOCIWFIRSTPRIV + 0x9:
		acx100_ioctl_list_reg_domain(wlandev);
		break;
  case SIOCIWFIRSTPRIV + 0xa:
		acx100_ioctl_get_reg_domain(wlandev, iwr);
		break;
  case SIOCIWFIRSTPRIV + 0xb:
		acx100_ioctl_set_reg_domain(wlandev, iwr);
		break;
		
	default:
		acxlog(L_IOCTL, "wireless ioctl 0x%04X queried but not implemented yet!\n", cmd);
		result = -EOPNOTSUPP;
		break;
	}


	if (wlandev->mode != 2 && reinit == 1) {

		if (!acx100_set_beacon_template(wlandev)) {
			acxlog(L_BINSTD,
			       "acx100_set_beacon_template returns error\n");
			result = -EFAULT;
		}

		if (!acx100_set_probe_response_template(wlandev)) {
			acxlog(L_BINSTD,
			       "acx100_set_probe_response_template returns error\n");
			result = -EFAULT;
		}

		acx_client_sta_list_init();
	}

	return result;
}

/* set_rx_mode()
 * STATUS: ok. FINISHED.
 */
static void set_rx_mode(netdevice_t * netdev)
{
	FN_ENTER;
}

/* acx100_interrupt()
 * STATUS: should be ok.
 */
static irqreturn_t acx100_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	wlandevice_t *wlandev =
	    (wlandevice_t *) (((netdevice_t *) dev_id)->priv);
	UINT16 irqtype = hwReadRegister16(wlandev, ACX100_IRQ_STATUS);
	unsigned long flags;
	static unsigned long count = 0;

	acxlog(L_IRQ, "IRQTYPE: %X, irq_mask: %X\n", irqtype,
	       wlandev->irq_mask);

	/* immediately return if we don't get signalled that an interrupt
	 * has occurred that we are interested in (interrupt sharing
	 * with other cards!) */
	if (!(irqtype &= ~(wlandev->irq_mask))) {
		return IRQ_NONE;
	}
	count++;
	acxlog(L_IRQ, "IRQ entry count: %ld\n", count);
#if 0
#if (DRIVER_VERSION & V4)
	hwDisableISR(wlandev);
#else
	disable_irq(irq);
#endif
#endif
	acx100_lock(wlandev,&flags);
	if (irqtype & 0x8) {
		dmaRxXfrISR(wlandev);
		hwWriteRegister16(wlandev, ACX100_IRQ_ACK, 0x8);
	}
	if (irqtype & 0x2) {
		
		dmaTxDataISR(wlandev);
		hwWriteRegister16(wlandev, ACX100_IRQ_ACK, 0x2);
	}
	if (irqtype & HOST_INT_SCAN_COMPLETE /* 0x2000 */ ) {
		/* V1_3CHANGE: dbg msg only in V1 */
		acxlog(L_IRQ,
		       "<acx100_interrupt> HOST_INT_SCAN_COMPLETE\n");

		if (wlandev->iStatus == ISTATUS_5_UNKNOWN) {
			wlandev->iStatus = wlandev->unknown0x2350;
			wlandev->unknown0x2350 = 0;
		} else if (wlandev->iStatus == ISTATUS_1_SCANNING) {

			d11CompleteScan(wlandev);
		}
		hwWriteRegister16(wlandev, ACX100_IRQ_ACK,
				  HOST_INT_SCAN_COMPLETE /* 0x2000 */ );
	}
	if (irqtype & HOST_INT_TIMER /* 0x40 */ ) {
		acx100_timer(wlandev);

		hwWriteRegister16(wlandev, ACX100_IRQ_ACK,
				  HOST_INT_TIMER /* 0x40 */ );
	}
	acx100_unlock(wlandev,&flags);
	count--;
#if 0
#if (DRIVER_VERSION & V4)
	hwEnableISR(wlandev);
#else
	enable_irq(irq);
#endif
#endif
	FN_EXIT(0, 0);
	return IRQ_HANDLED;
}

/* acx100_rx()
 * STATUS: *much* better now, maybe finally bug-free, VERIFIED.
 */
void acx100_rx(wlan_pb_t * pb, wlandevice_t * wlandev)
{
	netdevice_t *ndev;
	struct sk_buff *skb;

	FN_ENTER;
	if ((wlandev->state & 1)
	    && (pb->p80211_payloadlen != 0)) {
		if (!p80211pb_p80211_to_ether(wlandev, pb)) {
			ndev = root_acx100_dev.next;
			skb = pb->ethhostbuf;
#if (DRIVER_VERSION & V1)
			/* V1_3CHANGE */
			pb->ethhostbuf = NULL;
			pb->free = NULL;
#endif
			skb->dev = ndev;
			ndev->last_rx = jiffies;

			skb->protocol = eth_type_trans(skb, ndev);
			netif_rx(skb);

			wlandev->stats.rx_packets++;
			wlandev->stats.rx_bytes += skb->len;
#if !(DRIVER_VERSION & V1)	/* all other versions */
			/* V1_3CHANGE */
			pb->ethhostbuf = NULL;
			pb->ethfree = NULL;
#endif
		}
	}
	FN_EXIT(0, 0);
}

/*----------------------------------------------------------------
* init_module
*
* Module initialization routine, called once at module load time.
* This one simulates some of the pcmcia calls.
*
* Arguments:
*	none
*
* Returns:
*	0	- success
*	~0	- failure, module is unloaded.
*
* Side effects:
* 	alot
*
* Call context:
*	process thread (insmod or modprobe)
* STATUS: should be ok.. NONV3.
----------------------------------------------------------------*/

#ifdef MODULE

MODULE_PARM(debug, "i");
MODULE_PARM_DESC(debug, "Debug level mask: 0x01 - 0x0800");
MODULE_PARM(use_eth_name, "i");
MODULE_PARM_DESC(use_eth_name, "Allocate device ethX instead of wlanX");



#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,22))	//I think
int acx100_init_module(void)
#else
int init_module(void)
#endif
{
	FN_ENTER;		//.data(0x4)=version

//#ifdef MODULE
	acxlog(L_STD,
	       "acx100: It looks like you were coaxed into buying a wireless network card\n");
	acxlog(L_STD,
	       "acx100: that uses the mysterious ACX100 chip from Texas Instruments.\n");
	acxlog(L_STD,
	       "acx100: You should better have bought e.g. a PRISM(R) chipset based card,\n");
	acxlog(L_STD,
	       "acx100: since that would mean REAL vendor Linux support.\n");
	acxlog(L_STD,
	       "acx100: Given this info, it's plain evident that this driver is EXPERIMENTAL,\n");
	acxlog(L_STD,
	       "acx100: thus your mileage may vary. Visit http://acx100.sf.net for support.\n");

	acxlog(L_BINDEBUG, "init_module: %s Loaded\n", version);
	acxlog(L_BINDEBUG, "init_module: dev_info is: %s\n", dev_info);
	//.data(0xc)=dev_info

	/* This call will result in a call to acx100_probe_pci
	 * if there is a matching PCI card present (ie., which
	 * has matching vendor+device id)
	 */
	if (pci_register_driver(&acx100_pci_drv_id) <= 0) {
		acxlog(L_STD,
		       "init_module: acx100_pci: No devices found, driver not installed\n");
		pci_unregister_driver(&acx100_pci_drv_id);
		return -ENODEV;
	}
	FN_EXIT(0, 0);
	return 0;
}

/*----------------------------------------------------------------
* cleanup_module
*
* Called at module unload time.  This is our last chance to
* clean up after ourselves.
*
* Arguments:
*	none
*
* Returns:
*	nothing
*
* Side effects:
* 	alot
*
* Call context:
*	process thread
*
* STATUS: should be ok.
----------------------------------------------------------------*/

#if (LINUX_VERSION_CODE >KERNEL_VERSION(2,5,22))	//I think
void acx100_cleanup_module(void)
#else
void cleanup_module(void)
#endif
{
	netdevice_t *netdev;
	wlandevice_t *wlandev;
	netdevice_t *ndev;

	/*
	   for (link=dev_list; link != NULL; link = nlink) {
	   nlink = link->next;
	   if ( link->state & DEV_CONFIG ) {
	   prism2sta_release((u_long)link);
	   }
	   acx100_detach(link);
	 */
	/* remember detach() frees link */
	//      }

	FN_ENTER;

	pci_unregister_driver(&acx100_pci_drv_id);
	while (root_acx100_dev.next != NULL) {
		netdev = root_acx100_dev.next;
		wlandev /* ebx */  = (wlandevice_t *) netdev->priv;
		ndev /* esi */  = wlandev->next_nd;
		unregister_netdev(netdev);
		kfree(wlandev);
		kfree(root_acx100_dev.next);
		root_acx100_dev.next = ndev;
		/* V1_3CHANGE: dbg msg only in V1 */
		acxlog(L_BINDEBUG, "root_acx100_dev not zero.\n");
	}

	FN_EXIT(0, 0);
}


/* For kernels 2.5.* where modutils>=4,2,22, we must have an module_init and module_exit like so: */
#if (LINUX_VERSION_CODE >KERNEL_VERSION(2,5,22))	//I think
module_init(acx100_init_module);
module_exit(acx100_cleanup_module);
#endif

#endif /* MODULE */
